PRD: Person-to-Person Time-Based Authentication Mobile App

Introduction & Purpose

This product is a mobile app for person-to-person authentication. It allows two individuals to generate a common, time-based one-time passcode on their phones (similar to Google Authenticator) without any server or internet connection. The purpose is to enable two people to mutually verify each other’s identity or shared access by using a synchronized code that changes every 60 seconds. The app functions entirely locally on each device, ensuring privacy and security. Both users will see the same 6-digit code on their screens when paired, proving they share a secret key. This is achieved through the industry-standard Time-Based One-Time Password (TOTP) algorithm ￼ ￼.

Figure: Typical TOTP code generation flow. A shared secret (exchanged via QR code) combined with the current time yields an identical one-time code on two devices. In our app, both users’ phones play the role of “authenticator,” generating the same code simultaneously (no server needed).

Objectives and Goals
	•	Secure Two-Party Authentication: Provide a secure method for two people to share a secret key and generate identical time-based verification codes. This can be used to confirm identity or a shared trust between the two parties in real-time.
	•	Simplicity (MVP Scope): Deliver a minimal, easy-to-use app that works offline and requires no account registration or server connectivity. Version 1 will focus on local functionality to lower friction for users.
	•	Cross-Platform Availability: Ensure the app is available on both iOS and Android (so that “both” users, regardless of device platform, can use it together). Each person should have the same experience and capabilities on their device.
	•	Security and Privacy: Safeguard the shared secret key through encryption and secure storage on the device. No sensitive data is sent to any server. The app should follow best practices similar to other authenticators by protecting the secret key and only displaying temporary codes ￼.

User Stories / Use Cases
	•	Use Case 1 – Friends Verifying Identity: Alice and Bob often communicate remotely about confidential matters. They agree to use this app to verify each other on calls. Alice opens the app and pairs with Bob. Later, when Alice calls Bob, she asks “What code do you see?” Bob checks his app and replies with the code; Alice matches it with her own app’s code. If they match, both are assured they are speaking to the right person (since only their two devices share the secret).
	•	Use Case 2 – Shared Account Access Confirmation: Two co-founders of a project use the app to add an extra layer of security when performing sensitive actions. Both must read the same current code from their phones to confirm they each have the shared device at hand before proceeding (acting like a mutual two-factor check).
	•	Use Case 3 – Offline Verification: Carol and Dave are in a location with no internet, but they want to ensure they are both “in sync” for a secure operation (e.g., opening a lock or launching an event together). Using the app, they generate a common code offline. As long as both see the same code at that moment, they know they share the secret and are in agreement on time.

These scenarios illustrate the core value: a quick, trustworthy confirmation that both parties possess a shared secret at the same time, without needing SMS codes or server-based 2FA. The app can be thought of as a “peer-to-peer Google Authenticator” exclusively between two people.

Key Features and Requirements

1. Pairing & Secret Key Exchange
	•	Initiating a Pairing: Either user can initiate the process by clicking a “New Pair” button in the app. This generates a new random secret key (a base32 string as used in TOTP) and displays it as a QR code on-screen. The QR code encodes the secret (and optionally an identifier label) in a standard format (e.g. the otpauth:// URI scheme).
	•	Scanning to Connect: The other user chooses “Add Partner” or “Scan Code” on their app and scans the first user’s QR code using their phone’s camera. Upon scanning, that second app decodes the secret and saves it locally. Now both devices have the same secret key. (This mimics scanning a website’s QR in Google Authenticator, except here one phone scans another phone’s QR.)
	•	Confirmation of Sync: After a successful scan, both users should get a visual confirmation that pairing was successful. For example, the app can display a message like “Pairing successful – you are now synced with [Partner Name]”. Immediately, both should see an identical verification code on their screens, which will be the first time-based code generated from their shared secret. They can verify informally that the codes match. (In other words, scanning the same secret on two devices yields the same one-time code) ￼.
	•	Bidirectional Pairing: The pairing is inherently mutual – once one user scans the other’s QR, the secret is shared. There is no need for the second person to generate a separate QR back, since both now possess the same key. (If desired, the roles could be reversed to double-confirm, but it’s essentially the same shared secret on both sides.) Each pairing entry can be seen as a “contact” in the app that represents the link between two people.
	•	Multiple Pairings: A user can have multiple different shared keys (one per partner) saved in the app. For example, a user might pair with their spouse (one secret) and also pair with a colleague (another secret). The app’s home screen will list each active pairing with a label (the partner’s name or chosen label) and the current code for that pair. This is similar to how authenticator apps list multiple accounts with their codes. There should be an option to label each pairing for easy identification (e.g., “Alice <-> Bob code”).
	•	Manual Key Entry (Nice-to-have): In case scanning a QR isn’t possible (camera issues or remote pairing scenario), the app should allow manually entering the secret key on the second device. For MVP, QR scan is primary; manual entry is a fallback that can be included if it doesn’t add much complexity. (Users would need to communicate the secret out-of-band, which is less secure, so QR scanning in person is the recommended method).
	•	No Internet or Server Required: The entire pairing process is local. Showing/scanning the QR code does not require any network connection. There is no central server involved in exchanging the key – it’s transmitted visually via QR. This means users must be physically together (or on a video call) to hold one phone’s QR in front of the other’s camera. The benefit is that the secret key is never sent through an online channel. (TOTP codes can be generated completely offline as long as both devices share the secret and time ￼.)

2. Time-Based Code Generation (TOTP)
	•	TOTP Algorithm Standard: Once paired, both apps independently generate a one-time code using the standard TOTP method (Time-Based One-Time Password as per RFC 6238). This involves combining the secret key with the current time (in defined intervals) using a secure hash function (typically HMAC-SHA1) and truncating the result to a 6-digit code ￼. The app does not need internet for this; it relies on the device’s clock.
	•	6-Digit Numeric Code: The code displayed will be a six-digit number, as is common with authenticator apps (e.g., “528491”). It will reset to a new random 6-digit number every interval. Six digits are chosen for familiarity and usability (enough combinations to be secure, but short enough to compare or read out loud easily).
	•	60-Second Validity Interval: The one-time code changes every 60 seconds (unlike the 30-second interval used by Google Authenticator by default). This means each code is valid for a 1-minute window before a new code is generated. After 60 seconds, both users’ apps will independently roll to the next code. This 60-second period is an agreed design choice to give a slightly longer window for users to read/compare the code, though TOTP typically allows 30s by default ￼ ￼. The code is time-based, so it expires after 60s – if needed, users must use/verify it within that time before it changes. (Allowing a short grace of a few seconds past expiry is possible to account for minor clock differences, as TOTP implementations often do ￼ ￼.)
	•	Clock Synchronization: For the codes to match, both devices need to have reasonably synchronized clocks. The app will use the system time on each phone to calculate the code. Modern smartphones keep accurate time (via NTP or cellular network) and use UTC for such calculations ￼, so in most cases this “just works.” We assume users’ phones are set to auto-update time. (If one phone’s time is significantly off, the codes might differ; in future we could provide a time sync indicator or guidance to correct the clock).
	•	Visual Countdown Indicator: The UI will show a countdown or progress bar next to the code, indicating how long until it expires (0–60 seconds). This helps users know when a new code is coming. For example, a circular timer or bar that depletes, similar to Google Authenticator’s blue pie timer, can be used. When the timer runs out, the code value refreshes.
	•	Multiple Codes Display: If the user has multiple paired contacts, the app will display multiple codes (one per pairing) in a list, each with its own label and countdown. The user can scroll if needed to view all. This is analogous to having multiple accounts in Google Authenticator (see Figure: Authenticator UI example below). Each entry updates independently. Only the intended partner who shares that specific secret will have the matching code.

Figure: Example authenticator UI (Google Authenticator) showing 6-digit codes for different accounts. Our app would display a similar interface, but each code represents a pair between two people (e.g., “Alice & Bob” instead of an account name). A timer icon or progress bar indicates when the code will refresh ￼.
	•	Code Verification Use: The app does not automatically send or verify codes (since there’s no server), but users will utilize the codes externally (e.g., verbally confirm the numbers match). The assumption is if both see the same number at the same time, the secret is shared and both parties are authenticated to each other. If codes do not match, they are not in sync (either pairing failed or one device’s time is off).
	•	Error Handling: If a scanned QR code is invalid or not recognized, the app will alert the user (“Unable to add – QR code not valid.”). This could happen if the user accidentally scans a non-supported QR. For v1, we assume users scan only codes generated by the app (correct format), so this should be rare. Also, if the two devices somehow have desynchronized time leading to mismatched codes, the app can suggest checking clock settings.

3. Security & Encryption
	•	Secret Key Protection: The shared secret key (seed) that is stored on each device must be encrypted and securely stored. This is crucial because anyone who obtains this key could generate the same codes. We will leverage the mobile OS secure storage facilities:
	•	On iOS, the key can be stored in the Keychain (with Sensitive Data accessibility) or even the Secure Enclave.
	•	On Android, use the Android Keystore system to store the secret or an encrypted form of it, so that it’s sandboxed to the app.
The key should never be exposed in plaintext on the device file system. Secure enclave or keystore storage makes it difficult for unauthorized access to retrieve the secret ￼. Additionally, the app should never display the raw secret to the user after the initial setup (no “show QR of secret” to screen unless explicitly intended for adding a new device). This follows best practices: authenticator apps keep the secret confidential and only show the changing codes ￼.
	•	Encryption at Rest: If for some reason the secret must be stored outside secure enclave (e.g., in a preferences file), it should be encrypted with a key derivation from the device or user. Given v1 has no user login, we might rely on the device’s encryption (phone unlock). The app could generate a random encryption key and store it in the secure hardware, then use it to encrypt the TOTP secrets in local storage. The goal is that even if the phone is rooted or an attacker gets a file dump, the secrets are not easily compromised ￼.
	•	No Data in Transit: There is no client-server communication in v1, so the primary attack surface is on-device. By not transmitting codes or secrets over networks, we eliminate network interception risks. (When we add cloud sync in future versions, we will revisit transit security, likely using end-to-end encryption for any secret exchange).
	•	One-Time QR Exchange: The QR code shown during pairing contains the secret in a format meant for short-term use. We will instruct users to scan it immediately and not save it. If someone were to photograph that QR, they’d have the secret. Thus, the app could optionally hide the QR code after a timeout or after it’s scanned once. For MVP, manual user caution is fine (they should treat the QR as sensitive like a password). Future versions could include a mechanism: e.g., tap to reveal QR, auto-hide after 30 seconds.
	•	Application Lock (Future consideration): In v1, the app opens directly to the codes. For additional security, we might allow users to set a PIN or use biometric lock to open the app, to prevent anyone who picks up the unlocked phone from seeing the codes. This is not required in v1, but is a potential enhancement for users who desire more protection.

4. User Experience & Design
	•	Zero Setup & Registration: The app does not require creating an account or logging in. Users install it and can use it immediately. The first screen shows an empty list (if no pairs yet) and a clear call-to-action to “Add New Pair”. This low-friction setup is intentional to encourage adoption – the only requirement is that both parties install the app. (No email, no phone number verification in v1.)
	•	Minimal UI, Focus on Code: The interface should be simple and analogous to known authenticator apps. The main screen lists the shared code entries. Each entry shows:
	•	A label (the partner’s name or whatever identifier the user set, e.g., “Bob’s Code”). Possibly an icon or initials of the partner for quick identification.
	•	The 6-digit code in a large font for readability.
	•	A small countdown indicator or text (e.g., “20s remaining”).
	•	(Optionally) a refresh icon if the user wants to manually regenerate early (though typically not needed, code will roll over).
	•	Add New Pair Flow: Tapping “New Pair” should clearly walk the user through the steps:
	1.	Show the newly generated QR code full-screen for the other person to scan. Also display an alphanumeric code string below it (in case the camera cannot scan, this string can be read out and typed by the other).
	2.	Possibly prompt the user to ask the other person to scan now. A button “I’ve been scanned” or “Done” can return to the main screen. We might detect when the other user has successfully scanned (maybe by a simple sound or vibration on their end), but since there’s no direct device communication, we can’t automatically know. So a manual confirmation is fine.
	3.	After finishing, the app should allow the initiator to save a label for that pairing (e.g., “Paired with Alice”). The second user, upon scanning, should also be prompted to label the pairing (e.g., it could default to the initiator’s name if the QR encoded a name, or just “Partner 1” to be edited).
	•	Scan Flow: On the scanning side, the user taps “Scan Pair” and a camera viewfinder opens. They scan the QR; on success, the app shows “Pairing with [optional name] successful!” and asks for a label if needed. Then it goes to main screen showing the new code entry.
	•	Feedback and Errors: Use simple dialogs or toasts for errors (e.g., “Scan failed, please try again.”). On successful pairing, perhaps a green checkmark icon or highlight to reinforce success.
	•	No Internet Warning: Because the app works offline, if a user tries to use it without any network, it’s fine – we just need to ensure the OS doesn’t block camera use or anything. We might include a note in help that internet is not required. In fact, for privacy, the app might even ask no permissions except camera (for QR scanning). No need for contacts, location, etc., in v1. This lean permission model itself is a UX advantage (users know we aren’t collecting data).

5. Platforms & Technical Constraints
	•	Target OS: Android (5.0+) and iOS (11+ or whichever is reasonably current), to cover a wide range. Both platforms can be developed natively or using a cross-platform framework, but the UI should follow each platform’s guidelines to feel natural.
	•	Camera Access: The app requires camera permission for QR scanning. On first use, it will prompt the user to allow camera access. We will provide a brief justification in the permission dialog (“Camera is used to scan QR codes for pairing”). If the user denies, they cannot scan QRs; we should handle this by either asking again or instructing how to enable it.
	•	Time Source: Rely on the device’s system time. We trust the user’s phone clock; if the phone’s time is manual and wrong, codes won’t match. We might include a note in FAQ about keeping automatic time. Since no server to sync with, we won’t implement NTP ourselves in v1 (not necessary given typical phone behavior).
	•	Performance: TOTP generation is very lightweight (HMAC-SHA1 on a small input). The app will update codes on a 1-minute interval, which is trivial CPU usage. We must ensure a timer runs to update the UI every 60 seconds; this can be done with a background-safe timer or using system clock ticks when app is active. If the app is backgrounded, it can simply update when reopened (it doesn’t need to run constantly in background). There’s no heavy computation or network tasks, so battery impact is minimal.
	•	Storage: Each secret is just a short string (16-32 bytes) plus an optional label. We can store these in a small local database or encrypted preferences. The storage footprint is negligible (even 100 pairs would be tiny data).
	•	Scalability: Not a big concern for v1 (usage is personal), but conceivably if someone had many pairings, we should allow it. We can set an arbitrary limit if needed (e.g., 50 pairings) but likely unnecessary.

Future Enhancements (Post v1)

The following features are out-of-scope for version 1, but are noted for future consideration:
	•	User Registration & Cloud Sync: In future versions, we may introduce an optional account system. This would allow users to back up their pairings to the cloud or synchronize across multiple devices (for example, if a user wants the shared code on both their phone and tablet). If implemented, it must be done securely (e.g., end-to-end encryption of secrets before uploading) ￼ ￼. Account registration could also enable inviting a partner remotely (e.g., sending a secure link or code instead of physically scanning). However, this complexity (and potential security risk if not done right) is deliberately avoided in v1.
	•	Additional Identification Methods: Beyond QR code scanning, future versions might support pairing via other methods: for instance, using NFC tap to share the secret, or Bluetooth Low Energy if in proximity. Another idea is integrating with contacts or using a phone number/email to facilitate the connection (e.g., send an encrypted invitation that the other can accept to establish the shared key). These methods would require a server or a mediated communication channel, so they will be explored later, keeping security paramount.
	•	Multi-Factor or Biometric Confirmation: To further secure the app, a future update could allow an app lock with PIN/biometrics (so even if phone is unlocked, the app requires fingerprint or a code to open). This ensures only the intended user can view the codes. Additionally, we might allow an optional “confirm presence” feature where both users have to tap a button within the 60-second window to confirm they are actively using the code (though this again would need some network or direct device communication to exchange that confirmation).
	•	Customization and Settings: Future versions could let users choose the code length (6 digits is default, but maybe 8 digits for more security) or the interval (30 vs 60 seconds) to be compatible with other systems. We might also integrate an import/export feature to transfer pairings when the user gets a new phone – perhaps via generating a batch QR or using the cloud backup tied to an account.
	•	Group Codes: Currently, one secret = two people. In the future, we could consider a “group” mode where three or more people share the same secret to all see a common code. This could be useful for small teams that need a shared verification code. However, distributing a secret to a group reliably is more complex and may be better handled via a server or sequential pairings. For now, any group would have to pair devices one-on-one sharing the same secret manually.
	•	Integration with Services: Down the line, the app could integrate with other authentication services or act as a second-factor for apps that want peer confirmation. For example, an API could allow a service to check that two people both input the same TOTP code from their shared key, effectively using our app as a distributed 2FA. This is speculative, though – the core use case remains peer-to-peer authentication.

Success Metrics

(For completeness, some measures of success once the product is launched could be defined. These are not immediate requirements but help guide the project’s goals.)
	•	Successful Pairings: Track the number of successful pairing events (QR scans). This indicates the app is being used to connect people.
	•	Retention & Active Use: How often do paired users open the app to view codes? Are they continuing to use it regularly (a sign that the shared code is indeed useful)?
	•	User Feedback on Security: Through surveys or reviews, gauge if users feel more secure or find the app easy. Also monitor if there are any reported security issues or misunderstandings (e.g., someone not realizing they must keep their phone time accurate).
	•	Growth via Word of Mouth: Since this app inherently requires two people, each new user is likely bringing another. If the app is convenient, we expect organic growth in pairs. A high ratio of daily active users to pairings could indicate repeated use vs. one-time use.

Conclusion

Version 1 of the Person-to-Person Authenticator App will deliver a simple yet powerful tool for two individuals to share a time-based one-time code, akin to having a private Google Authenticator channel between them. By focusing on local device functionality, strong security practices, and an easy UI, the product aims to build trust and prove the concept. Future enhancements will build on this foundation by adding connectivity and more advanced features, but the MVP’s success lies in securely generating synchronized codes on two phones with as little friction as possible.

In summary, this app will empower users with a shared secret key that’s safely stored and used to produce matching 60-second codes on their screens ￼. If both people see the same six-digit number at the same time, they can be confident they are “in sync” – a simple idea with many potential applications in authentication and verification scenarios.
